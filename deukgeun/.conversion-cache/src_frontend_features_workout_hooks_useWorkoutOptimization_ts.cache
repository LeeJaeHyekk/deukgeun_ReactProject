{"key":"51b9e6bfa2446a4d19194e1a83a2f40c","result":"// Browser API polyfills for Node.js environment\nif (typeof window === 'undefined') {\n  global.window = global.window || {}\n  global.document = global.document || {}\n  global.localStorage = global.localStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.sessionStorage = global.sessionStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.File = global.File || class File {}\n  global.StorageEvent = global.StorageEvent || class StorageEvent {}\n  global.requestAnimationFrame = global.requestAnimationFrame || (cb => setTimeout(cb, 16))\n}\n\nconst { useCallback, useRef, useEffect, useMemo  } = require('react')\r\nconst { useState  } = require('react')\r\n\r\n// 디바운스 훅\r\nexport function useDebounce<T extends (...args: any[]) => any>(\r\n  callback: T,\r\n  delay: number\r\n): T {\r\n  const timeoutRef = useRef<NodeJS.Timeout>()\r\n\r\n  return useCallback(\r\n    (...args: Parameters<T>) => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current)\r\n      }\r\n      timeoutRef.current = setTimeout(() => callback(...args), delay)\r\n    },\r\n    [callback, delay]\r\n  ) as T\r\n}\r\n\r\n// 스로틀 훅\r\nexport function useThrottle<T extends (...args: any[]) => any>(\r\n  callback: T,\r\n  delay: number\r\n): T {\r\n  const lastCall = useRef(0)\r\n  const lastCallTimer = useRef<NodeJS.Timeout>()\r\n\r\n  return useCallback(\r\n    (...args: Parameters<T>) => {\r\n      const now = Date.now()\r\n      if (now - lastCall.current >= delay) {\r\n        callback(...args)\r\n        lastCall.current = now\r\n      } else {\r\n        if (lastCallTimer.current) {\r\n          clearTimeout(lastCallTimer.current)\r\n        }\r\n        lastCallTimer.current = setTimeout(\r\n          () => {\r\n            callback(...args)\r\n            lastCall.current = Date.now()\r\n          },\r\n          delay - (now - lastCall.current)\r\n        )\r\n      }\r\n    },\r\n    [callback, delay]\r\n  ) as T\r\n}\r\n\r\n// 로컬 스토리지 훅\r\nexport function useLocalStorage<T>(key: string, initialValue: T) {\r\n  const [storedValue, setStoredValue] = useState<T>(() => {\r\n    try {\r\n      const item = window.localStorage.getItem(key)\r\n      return item ? JSON.parse(item) : initialValue\r\n    } catch (error) {\r\n      console.error(`Error reading localStorage key \"${key}\":`, error)\r\n      return initialValue\r\n    }\r\n  })\r\n\r\n  const setValue = useCallback(\r\n    (value: T | ((val: T) => T)) => {\r\n      try {\r\n        const valueToStore =\r\n          value instanceof Function ? value(storedValue) : value\r\n        setStoredValue(valueToStore)\r\n        window.localStorage.setItem(key, JSON.stringify(valueToStore))\r\n      } catch (error) {\r\n        console.error(`Error setting localStorage key \"${key}\":`, error)\r\n      }\r\n    },\r\n    [key, storedValue]\r\n  )\r\n\r\n  return [storedValue, setValue] as const\r\n}\r\n\r\n// 세션 스토리지 훅\r\nexport function useSessionStorage<T>(key: string, initialValue: T) {\r\n  const [storedValue, setStoredValue] = useState<T>(() => {\r\n    try {\r\n      const item = window.sessionStorage.getItem(key)\r\n      return item ? JSON.parse(item) : initialValue\r\n    } catch (error) {\r\n      console.error(`Error reading sessionStorage key \"${key}\":`, error)\r\n      return initialValue\r\n    }\r\n  })\r\n\r\n  const setValue = useCallback(\r\n    (value: T | ((val: T) => T)) => {\r\n      try {\r\n        const valueToStore =\r\n          value instanceof Function ? value(storedValue) : value\r\n        setStoredValue(valueToStore)\r\n        window.sessionStorage.setItem(key, JSON.stringify(valueToStore))\r\n      } catch (error) {\r\n        console.error(`Error setting sessionStorage key \"${key}\":`, error)\r\n      }\r\n    },\r\n    [key, storedValue]\r\n  )\r\n\r\n  return [storedValue, setValue] as const\r\n}\r\n\r\n// 인터섹션 옵저버 훅\r\nexport function useIntersectionObserver(\r\n  options: IntersectionObserverInit = {}\r\n) {\r\n  const [isIntersecting, setIsIntersecting] = useState(false)\r\n  const [entry, setEntry] = useState<IntersectionObserverEntry | null>(null)\r\n  const elementRef = useRef<Element | null>(null)\r\n\r\n  const callback = useCallback((entries: IntersectionObserverEntry[]) => {\r\n    const [entry] = entries\r\n    setIsIntersecting(entry.isIntersecting)\r\n    setEntry(entry)\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    const element = elementRef.current\r\n    if (!element) return\r\n\r\n    const observer = new IntersectionObserver(callback, options)\r\n    observer.observe(element)\r\n\r\n    return () => observer.disconnect()\r\n  }, [callback, options])\r\n\r\n  return [elementRef, isIntersecting, entry] as const\r\n}\r\n\r\n// 윈도우 리사이즈 훅\r\nexport function useWindowResize() {\r\n  const [windowSize, setWindowSize] = useState({\r\n    width: window.innerWidth,\r\n    height: window.innerHeight,\r\n  })\r\n\r\n  useEffect(() => {\r\n    const handleResize = () => {\r\n      setWindowSize({\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n      })\r\n    }\r\n\r\n    window.addEventListener('resize', handleResize)\r\n    return () => window.removeEventListener('resize', handleResize)\r\n  }, [])\r\n\r\n  return windowSize\r\n}\r\n\r\n// 키보드 이벤트 훅\r\nexport function useKeyboardEvent(\r\n  key: string,\r\n  callback: (event: KeyboardEvent) => void,\r\n  options: { ctrl?: boolean; shift?: boolean; alt?: boolean } = {}\r\n) {\r\n  useEffect(() => {\r\n    const handleKeyDown = (event: KeyboardEvent) => {\r\n      if (event.key === key) {\r\n        const { ctrl, shift, alt } = options\r\n        if (\r\n          (!ctrl || event.ctrlKey) &&\r\n          (!shift || event.shiftKey) &&\r\n          (!alt || event.altKey)\r\n        ) {\r\n          callback(event)\r\n        }\r\n      }\r\n    }\r\n\r\n    window.addEventListener('keydown', handleKeyDown)\r\n    return () => window.removeEventListener('keydown', handleKeyDown)\r\n  }, [key, callback, options])\r\n}\r\n\r\n// 클릭 외부 감지 훅\r\nexport function useClickOutside(\r\n  ref: React.RefObject<HTMLElement>,\r\n  callback: () => void\r\n) {\r\n  useEffect(() => {\r\n    const handleClickOutside = (event: MouseEvent) => {\r\n      if (ref.current && !ref.current.contains(event.target as Node)) {\r\n        callback()\r\n      }\r\n    }\r\n\r\n    document.addEventListener('mousedown', handleClickOutside)\r\n    return () => document.removeEventListener('mousedown', handleClickOutside)\r\n  }, [ref, callback])\r\n}\r\n\r\n// 포커스 트랩 훅\r\nexport function useFocusTrap(enabled: boolean = true) {\r\n  const containerRef = useRef<HTMLElement>(null)\r\n\r\n  useEffect(() => {\r\n    if (!enabled) return\r\n\r\n    const container = containerRef.current\r\n    if (!container) return\r\n\r\n    const focusableElements = container.querySelectorAll(\r\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\r\n    )\r\n    const firstElement = focusableElements[0] as HTMLElement\r\n    const lastElement = focusableElements[\r\n      focusableElements.length - 1\r\n    ] as HTMLElement\r\n\r\n    const handleKeyDown = (event: KeyboardEvent) => {\r\n      if (event.key === 'Tab') {\r\n        if (event.shiftKey) {\r\n          if (document.activeElement === firstElement) {\r\n            event.preventDefault()\r\n            lastElement.focus()\r\n          }\r\n        } else {\r\n          if (document.activeElement === lastElement) {\r\n            event.preventDefault()\r\n            firstElement.focus()\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    container.addEventListener('keydown', handleKeyDown)\r\n    return () => container.removeEventListener('keydown', handleKeyDown)\r\n  }, [enabled])\r\n\r\n  return containerRef\r\n}\r\n\r\n// 가상화 훅 (대용량 리스트 최적화)\r\nexport function useVirtualization<T>(\r\n  items: T[],\r\n  itemHeight: number,\r\n  containerHeight: number\r\n) {\r\n  const [scrollTop, setScrollTop] = useState(0)\r\n\r\n  const visibleItems = useMemo(() => {\r\n    const startIndex = Math.floor(scrollTop / itemHeight)\r\n    const endIndex = Math.min(\r\n      startIndex + Math.ceil(containerHeight / itemHeight) + 1,\r\n      items.length\r\n    )\r\n\r\n    return items.slice(startIndex, endIndex).map((item, index) => ({\r\n      item,\r\n      index: startIndex + index,\r\n      style: {\r\n        position: 'absolute' as const,\r\n        top: (startIndex + index) * itemHeight,\r\n        height: itemHeight,\r\n        width: '100%',\r\n      },\r\n    }))\r\n  }, [items, itemHeight, containerHeight, scrollTop])\r\n\r\n  const totalHeight = items.length * itemHeight\r\n\r\n  const handleScroll = useCallback((event: React.UIEvent<HTMLDivElement>) => {\r\n    setScrollTop(event.currentTarget.scrollTop)\r\n  }, [])\r\n\r\n  return {\r\n    visibleItems,\r\n    totalHeight,\r\n    handleScroll,\r\n  }\r\n}\r\n\r\n// 워크아웃 데이터 최적화 훅\r\nexport function useWorkoutDataOptimization() {\r\n  // 자주 사용되는 데이터 메모이제이션\r\n  const memoizedStats = useMemo(() => {\r\n    // 통계 계산 로직\r\n    return {\r\n      totalWorkouts: 0,\r\n      averageDuration: 0,\r\n      totalCalories: 0,\r\n      streakDays: 0,\r\n    }\r\n  }, [])\r\n\r\n  // 데이터 캐싱\r\n  const [cachedData, setCachedData] = useLocalStorage('workout-cache', {})\r\n\r\n  // 캐시 무효화\r\n  const invalidateCache = useCallback(() => {\r\n    setCachedData({})\r\n  }, [setCachedData])\r\n\r\n  return {\r\n    memoizedStats,\r\n    cachedData,\r\n    invalidateCache,\r\n  }\r\n}\r\n\r\n// 성능 모니터링 훅\r\nexport function usePerformanceMonitor(componentName: string) {\r\n  const renderCount = useRef(0)\r\n  const lastRenderTime = useRef(performance.now())\r\n\r\n  useEffect(() => {\r\n    renderCount.current += 1\r\n    const currentTime = performance.now()\r\n    const timeSinceLastRender = currentTime - lastRenderTime.current\r\n    lastRenderTime.current = currentTime\r\n\r\n    if (process.env.MODE === 'development') {\r\n      console.log(\r\n        `${componentName} rendered ${renderCount.current} times. Time since last render: ${timeSinceLastRender.toFixed(2)}ms`\r\n      )\r\n    }\r\n  })\r\n\r\n  return {\r\n    renderCount: renderCount.current,\r\n  }\r\n}\r\n","timestamp":1759907919175}