{"key":"cf188aeaad8e2a54dc8424e53b2d10e3","result":"// Browser API polyfills for Node.js environment\nif (typeof window === 'undefined') {\n  global.window = global.window || {}\n  global.document = global.document || {}\n  global.localStorage = global.localStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.sessionStorage = global.sessionStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.File = global.File || class File {}\n  global.StorageEvent = global.StorageEvent || class StorageEvent {}\n  global.requestAnimationFrame = global.requestAnimationFrame || (cb => setTimeout(cb, 16))\n}\n\nimport React, { Component, ErrorInfo, ReactNode } from \"react\"\r\nconst ErrorPage = require('./ErrorPage').default\r\n\r\ninterface Props {\r\n  children: ReactNode\r\n  fallback?: ReactNode\r\n  onError?: (error: Error, errorInfo: ErrorInfo) => void\r\n}\r\n\r\ninterface State {\r\n  hasError: boolean\r\n  error?: Error\r\n  errorInfo?: ErrorInfo\r\n}\r\n\r\nexport class ErrorBoundary extends Component<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error): State {\r\n    // 에러가 발생하면 상태를 업데이트하여 다음 렌더링에서 폴백 UI를 표시\r\n    return { hasError: true, error }\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\r\n    // 에러 로깅\r\n    console.error(\"ErrorBoundary caught an error:\", error, errorInfo)\r\n\r\n    // 에러 정보를 상태에 저장\r\n    this.setState({ error, errorInfo })\r\n\r\n    // 사용자 정의 에러 핸들러 호출\r\n    if (this.props.onError) {\r\n      this.props.onError(error, errorInfo)\r\n    }\r\n\r\n    // 에러 리포팅 (선택사항)\r\n    this.reportError(error, errorInfo)\r\n  }\r\n\r\n  private reportError = (error: Error, errorInfo: ErrorInfo) => {\r\n    // 에러 리포팅 로직 (예: Sentry, LogRocket 등)\r\n    try {\r\n      // 개발 환경에서는 콘솔에 출력\r\n      if (process.env.DEV) {\r\n        console.group(\"🚨 Error Boundary Report\")\r\n        console.error(\"Error:\", error)\r\n        console.error(\"Error Info:\", errorInfo)\r\n        console.error(\"Component Stack:\", errorInfo.componentStack)\r\n        console.groupEnd()\r\n      }\r\n\r\n      // 프로덕션 환경에서는 에러 리포팅 서비스로 전송\r\n      if (process.env.PROD) {\r\n        // 예시: Sentry로 에러 전송\r\n        // Sentry.captureException(error, { extra: errorInfo })\r\n\r\n        // 또는 자체 에러 로깅 API 호출\r\n        this.sendErrorToServer(error, errorInfo)\r\n      }\r\n    } catch (reportingError) {\r\n      console.error(\"Error reporting failed:\", reportingError)\r\n    }\r\n  }\r\n\r\n  private sendErrorToServer = async (error: Error, errorInfo: ErrorInfo) => {\r\n    try {\r\n      const errorReport = {\r\n        message: error.message,\r\n        stack: error.stack,\r\n        componentStack: errorInfo.componentStack,\r\n        timestamp: new Date().toISOString(),\r\n        userAgent: navigator.userAgent,\r\n        url: window.location.href,\r\n        // 추가 컨텍스트 정보\r\n        context: {\r\n          userId: localStorage.getItem(\"userId\") || \"anonymous\",\r\n          sessionId: sessionStorage.getItem(\"sessionId\") || \"unknown\",\r\n        },\r\n      }\r\n\r\n      // 에러 리포팅 API 호출 (실제 구현 시 활성화)\r\n      // await fetch(\"/api/errors\", {\r\n      //   method: \"POST\",\r\n      //   headers: { \"Content-Type\": \"application/json\" },\r\n      //   body: JSON.stringify(errorReport),\r\n      // })\r\n\r\n      console.log(\"Error report prepared:\", errorReport)\r\n    } catch (sendError) {\r\n      console.error(\"Failed to send error to server:\", sendError)\r\n    }\r\n  }\r\n\r\n  private handleRetry = () => {\r\n    // 에러 상태를 리셋하고 컴포넌트를 다시 렌더링\r\n    this.setState({ hasError: false, error: undefined, errorInfo: undefined })\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // 사용자 정의 폴백 UI가 있으면 사용\r\n      if (this.props.fallback) {\r\n        return this.props.fallback\r\n      }\r\n\r\n      // 기본 에러 페이지 표시\r\n      return (\r\n        <ErrorPage\r\n          statusCode={500}\r\n          title=\"애플리케이션 오류\"\r\n          message=\"예상치 못한 오류가 발생했습니다. 페이지를 새로고침하거나 다시 시도해주세요.\"\r\n          showRetryButton={true}\r\n          onRetry={this.handleRetry}\r\n        />\r\n      )\r\n    }\r\n\r\n    return this.props.children\r\n  }\r\n}\r\n\r\n// 함수형 컴포넌트를 위한 에러 바운더리 래퍼\r\nexport function withErrorBoundary<P extends object>(\r\n  Component: React.ComponentType<P>,\r\n  errorBoundaryProps?: Partial<Props>\r\n) {\r\n  return function WrappedComponent(props: P) {\r\n    return (\r\n      <ErrorBoundary {...errorBoundaryProps}>\r\n        <Component {...props} />\r\n      </ErrorBoundary>\r\n    )\r\n  }\r\n}\r\n\r\n// 훅 기반 에러 바운더리 (함수형 컴포넌트용)\r\nexport function useErrorBoundary() {\r\n  const [error, setError] = React.useState<Error | null>(null)\r\n\r\n  const handleError = React.useCallback(\r\n    (error: Error, errorInfo: ErrorInfo) => {\r\n      console.error(\"useErrorBoundary caught an error:\", error, errorInfo)\r\n      setError(error)\r\n    },\r\n    []\r\n  )\r\n\r\n  const resetError = React.useCallback(() => {\r\n    setError(null)\r\n  }, [])\r\n\r\n  return {\r\n    error,\r\n    handleError,\r\n    resetError,\r\n  }\r\n}\r\n\r\n// 에러 바운더리 컨텍스트\r\ninterface ErrorBoundaryContextType {\r\n  reportError: (error: Error, errorInfo?: ErrorInfo) => void\r\n  clearError: () => void\r\n  hasError: boolean\r\n}\r\n\r\nconst ErrorBoundaryContext =\r\n  React.createContext<ErrorBoundaryContextType | null>(null)\r\n\r\nexport function ErrorBoundaryProvider({ children }: { children: ReactNode }) {\r\n  const [errors, setErrors] = React.useState<\r\n    Array<{ error: Error; errorInfo?: ErrorInfo; timestamp: Date }>\r\n  >([])\r\n\r\n  const reportError = React.useCallback(\r\n    (error: Error, errorInfo?: ErrorInfo) => {\r\n      setErrors(prev => [...prev, { error, errorInfo, timestamp: new Date() }])\r\n    },\r\n    []\r\n  )\r\n\r\n  const clearError = React.useCallback(() => {\r\n    setErrors([])\r\n  }, [])\r\n\r\n  const value = React.useMemo(\r\n    () => ({\r\n      reportError,\r\n      clearError,\r\n      hasError: errors.length > 0,\r\n    }),\r\n    [reportError, clearError, errors.length]\r\n  )\r\n\r\n  return (\r\n    <ErrorBoundaryContext.Provider value={value}>\r\n      {children}\r\n    </ErrorBoundaryContext.Provider>\r\n  )\r\n}\r\n\r\nexport function useErrorBoundaryContext() {\r\n  const context = React.useContext(ErrorBoundaryContext)\r\n  if (!context) {\r\n    throw new Error(\r\n      \"useErrorBoundaryContext must be used within ErrorBoundaryProvider\"\r\n    )\r\n  }\r\n  return context\r\n}\r\n\r\nmodule.exports.default = ErrorBoundary\r\n","timestamp":1759820789675}