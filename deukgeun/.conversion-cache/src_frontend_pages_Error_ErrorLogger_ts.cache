{"key":"cbfafc665f4ce530a05a13ad0625f107","result":"// Browser API polyfills for Node.js environment\nif (typeof window === 'undefined') {\n  global.window = global.window || {}\n  global.document = global.document || {}\n  global.localStorage = global.localStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.sessionStorage = global.sessionStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.File = global.File || class File {}\n  global.StorageEvent = global.StorageEvent || class StorageEvent {}\n  global.requestAnimationFrame = global.requestAnimationFrame || (cb => setTimeout(cb, 16))\n}\n\n// 에러 로깅 및 분석 시스템\r\n\r\ninterface ErrorLog {\r\n  id: string\r\n  timestamp: Date\r\n  errorType: string\r\n  message: string\r\n  stack?: string\r\n  url: string\r\n  userAgent: string\r\n  userId?: string\r\n  sessionId?: string\r\n  componentStack?: string\r\n  severity: \"low\" | \"medium\" | \"high\" | \"critical\"\r\n  metadata?: Record<string, any>\r\n}\r\n\r\ninterface ErrorAnalytics {\r\n  totalErrors: number\r\n  errorsByType: Record<string, number>\r\n  errorsBySeverity: Record<string, number>\r\n  recentErrors: ErrorLog[]\r\n  errorTrends: {\r\n    hourly: Record<string, number>\r\n    daily: Record<string, number>\r\n  }\r\n}\r\n\r\nclass ErrorLogger {\r\n  private logs: ErrorLog[] = []\r\n  private readonly MAX_LOGS = 1000\r\n  private readonly FLUSH_INTERVAL = 5 * 60 * 1000 // 5분\r\n  private flushTimer?: NodeJS.Timeout\r\n\r\n  constructor() {\r\n    this.initializeFlushTimer()\r\n  }\r\n\r\n  private initializeFlushTimer() {\r\n    // 주기적으로 로그를 서버로 전송\r\n    this.flushTimer = setInterval(() => {\r\n      this.flushLogs()\r\n    }, this.FLUSH_INTERVAL)\r\n  }\r\n\r\n  /**\r\n   * 에러 로그 추가\r\n   */\r\n  logError(\r\n    error: Error,\r\n    context: {\r\n      errorType: string\r\n      userId?: string\r\n      sessionId?: string\r\n      componentStack?: string\r\n      metadata?: Record<string, any>\r\n    }\r\n  ): void {\r\n    const errorLog: ErrorLog = {\r\n      id: this.generateId(),\r\n      timestamp: new Date(),\r\n      errorType: context.errorType,\r\n      message: error.message,\r\n      stack: error.stack,\r\n      url: window.location.href,\r\n      userAgent: navigator.userAgent,\r\n      userId: context.userId,\r\n      sessionId: context.sessionId,\r\n      componentStack: context.componentStack,\r\n      severity: this.calculateSeverity(error, context.errorType),\r\n      metadata: context.metadata,\r\n    }\r\n\r\n    this.logs.push(errorLog)\r\n\r\n    // 최대 로그 개수 제한\r\n    if (this.logs.length > this.MAX_LOGS) {\r\n      this.logs.shift()\r\n    }\r\n\r\n    // 개발 환경에서는 즉시 콘솔에 출력\r\n    if (process.env.DEV) {\r\n      this.logToConsole(errorLog)\r\n    }\r\n\r\n    // 심각한 에러는 즉시 서버로 전송\r\n    if (errorLog.severity === \"critical\" || errorLog.severity === \"high\") {\r\n      this.sendToServer([errorLog])\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 에러 심각도 계산\r\n   */\r\n  private calculateSeverity(\r\n    error: Error,\r\n    errorType: string\r\n  ): \"low\" | \"medium\" | \"high\" | \"critical\" {\r\n    // 에러 타입별 기본 심각도\r\n    const typeSeverity: Record<string, \"low\" | \"medium\" | \"high\" | \"critical\"> =\r\n      {\r\n        javascript: \"medium\",\r\n        network: \"high\",\r\n        promise: \"medium\",\r\n        resource: \"low\",\r\n      }\r\n\r\n    let severity = typeSeverity[errorType] || \"medium\"\r\n\r\n    // 에러 메시지 기반 심각도 조정\r\n    const message = error.message.toLowerCase()\r\n\r\n    if (message.includes(\"critical\") || message.includes(\"fatal\")) {\r\n      severity = \"critical\"\r\n    } else if (message.includes(\"network\") || message.includes(\"connection\")) {\r\n      severity = \"high\"\r\n    } else if (message.includes(\"validation\") || message.includes(\"format\")) {\r\n      severity = \"low\"\r\n    }\r\n\r\n    // 스택 트레이스 길이로 심각도 조정\r\n    if (error.stack && error.stack.split(\"\\n\").length > 10) {\r\n      severity = severity === \"low\" ? \"medium\" : severity\r\n    }\r\n\r\n    return severity\r\n  }\r\n\r\n  /**\r\n   * 콘솔에 로그 출력\r\n   */\r\n  private logToConsole(errorLog: ErrorLog): void {\r\n    const { severity, errorType, message, timestamp } = errorLog\r\n\r\n    const severityColors = {\r\n      low: \"#6b7280\",\r\n      medium: \"#f59e0b\",\r\n      high: \"#ef4444\",\r\n      critical: \"#dc2626\",\r\n    }\r\n\r\n    const color = severityColors[severity]\r\n\r\n    console.group(\r\n      `%c🚨 ${severity.toUpperCase()} ${errorType.toUpperCase()} ERROR`,\r\n      `color: ${color}; font-weight: bold;`\r\n    )\r\n    console.error(\"Message:\", message)\r\n    console.error(\"Timestamp:\", timestamp.toISOString())\r\n    console.error(\"URL:\", errorLog.url)\r\n    console.error(\"Severity:\", severity)\r\n    if (errorLog.stack) {\r\n      console.error(\"Stack:\", errorLog.stack)\r\n    }\r\n    if (errorLog.metadata) {\r\n      console.error(\"Metadata:\", errorLog.metadata)\r\n    }\r\n    console.groupEnd()\r\n  }\r\n\r\n  /**\r\n   * 서버로 로그 전송\r\n   */\r\n  private async sendToServer(logs: ErrorLog[]): Promise<void> {\r\n    try {\r\n      const payload = {\r\n        logs: logs.map(log => ({\r\n          ...log,\r\n          timestamp: log.timestamp.toISOString(),\r\n        })),\r\n        environment: process.env.MODE,\r\n        version: process.env.VITE_APP_VERSION || \"unknown\",\r\n      }\r\n\r\n      // 실제 구현 시 활성화\r\n      // await fetch(\"/api/errors/log\", {\r\n      //   method: \"POST\",\r\n      //   headers: { \"Content-Type\": \"application/json\" },\r\n      //   body: JSON.stringify(payload),\r\n      // })\r\n\r\n      console.log(\"Error logs sent to server:\", payload)\r\n    } catch (error) {\r\n      console.error(\"Failed to send error logs to server:\", error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 로그 플러시 (주기적 전송)\r\n   */\r\n  private async flushLogs(): Promise<void> {\r\n    if (this.logs.length === 0) return\r\n\r\n    const logsToSend = [...this.logs]\r\n    this.logs = []\r\n\r\n    await this.sendToServer(logsToSend)\r\n  }\r\n\r\n  /**\r\n   * 에러 분석 데이터 생성\r\n   */\r\n  getAnalytics(): ErrorAnalytics {\r\n    const now = new Date()\r\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000)\r\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000)\r\n\r\n    const recentErrors = this.logs.filter(log => log.timestamp > oneHourAgo)\r\n\r\n    const errorsByType = this.logs.reduce(\r\n      (acc, log) => {\r\n        acc[log.errorType] = (acc[log.errorType] || 0) + 1\r\n        return acc\r\n      },\r\n      {} as Record<string, number>\r\n    )\r\n\r\n    const errorsBySeverity = this.logs.reduce(\r\n      (acc, log) => {\r\n        acc[log.severity] = (acc[log.severity] || 0) + 1\r\n        return acc\r\n      },\r\n      {} as Record<string, number>\r\n    )\r\n\r\n    const hourlyTrends = this.logs\r\n      .filter(log => log.timestamp > oneDayAgo)\r\n      .reduce(\r\n        (acc, log) => {\r\n          const hour = log.timestamp.getHours().toString()\r\n          acc[hour] = (acc[hour] || 0) + 1\r\n          return acc\r\n        },\r\n        {} as Record<string, number>\r\n      )\r\n\r\n    const dailyTrends = this.logs\r\n      .filter(\r\n        log => log.timestamp > new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)\r\n      )\r\n      .reduce(\r\n        (acc, log) => {\r\n          const day = log.timestamp.toDateString()\r\n          acc[day] = (acc[day] || 0) + 1\r\n          return acc\r\n        },\r\n        {} as Record<string, number>\r\n      )\r\n\r\n    return {\r\n      totalErrors: this.logs.length,\r\n      errorsByType,\r\n      errorsBySeverity,\r\n      recentErrors,\r\n      errorTrends: {\r\n        hourly: hourlyTrends,\r\n        daily: dailyTrends,\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 특정 조건의 에러 검색\r\n   */\r\n  searchErrors(criteria: {\r\n    errorType?: string\r\n    severity?: string\r\n    startDate?: Date\r\n    endDate?: Date\r\n    userId?: string\r\n  }): ErrorLog[] {\r\n    return this.logs.filter(log => {\r\n      if (criteria.errorType && log.errorType !== criteria.errorType)\r\n        return false\r\n      if (criteria.severity && log.severity !== criteria.severity) return false\r\n      if (criteria.startDate && log.timestamp < criteria.startDate) return false\r\n      if (criteria.endDate && log.timestamp > criteria.endDate) return false\r\n      if (criteria.userId && log.userId !== criteria.userId) return false\r\n      return true\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 로그 클리어\r\n   */\r\n  clearLogs(): void {\r\n    this.logs = []\r\n  }\r\n\r\n  /**\r\n   * 고유 ID 생성\r\n   */\r\n  private generateId(): string {\r\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n\r\n  /**\r\n   * 리소스 정리\r\n   */\r\n  destroy(): void {\r\n    if (this.flushTimer) {\r\n      clearInterval(this.flushTimer)\r\n    }\r\n    this.flushLogs()\r\n  }\r\n}\r\n\r\n// 싱글톤 인스턴스\r\nexport const errorLogger = new ErrorLogger()\r\n\r\n// 편의 함수들\r\nexport const logError = (\r\n  error: Error,\r\n  context: {\r\n    errorType: string\r\n    userId?: string\r\n    sessionId?: string\r\n    componentStack?: string\r\n    metadata?: Record<string, any>\r\n  }\r\n) => {\r\n  errorLogger.logError(error, context)\r\n}\r\n\r\nexport const getErrorAnalytics = () => errorLogger.getAnalytics()\r\n\r\nexport const searchErrors = (\r\n  criteria: Parameters<typeof errorLogger.searchErrors>[0]\r\n) => errorLogger.searchErrors(criteria)\r\n\r\nexport const clearErrorLogs = () => errorLogger.clearLogs()\r\n\r\nmodule.exports.default = errorLogger\r\n","timestamp":1759820789680}