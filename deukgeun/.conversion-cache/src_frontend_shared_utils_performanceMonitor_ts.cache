{"key":"efe82316a4420c1685a173e4651fdcf4","result":"// Browser API polyfills for Node.js environment\nif (typeof window === 'undefined') {\n  global.window = global.window || {}\n  global.document = global.document || {}\n  global.localStorage = global.localStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.sessionStorage = global.sessionStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.File = global.File || class File {}\n  global.StorageEvent = global.StorageEvent || class StorageEvent {}\n  global.requestAnimationFrame = global.requestAnimationFrame || (cb => setTimeout(cb, 16))\n}\n\n// Performance API 타입 확장\r\ninterface PerformanceNavigationTiming extends PerformanceEntry {\r\n  loadEventEnd: number\r\n  loadEventStart: number\r\n  domContentLoadedEventEnd: number\r\n  domContentLoadedEventStart: number\r\n}\r\n\r\ninterface PerformancePaintTiming extends PerformanceEntry {\r\n  name: string\r\n  startTime: number\r\n}\r\n\r\ninterface PerformanceInputTiming extends PerformanceEntry {\r\n  processingStart: number\r\n  startTime: number\r\n}\r\n\r\ninterface PerformanceLayoutShift extends PerformanceEntry {\r\n  value: number\r\n  hadRecentInput: boolean\r\n}\r\n\r\ninterface PerformanceMemory {\r\n  usedJSHeapSize: number\r\n  totalJSHeapSize: number\r\n  jsHeapSizeLimit: number\r\n}\r\n\r\ninterface PerformanceMetrics {\r\n  pageLoadTime: number\r\n  domContentLoaded: number\r\n  firstContentfulPaint: number\r\n  largestContentfulPaint: number\r\n  firstInputDelay: number\r\n  cumulativeLayoutShift: number\r\n  memoryUsage?: {\r\n    usedJSHeapSize: number\r\n    totalJSHeapSize: number\r\n    jsHeapSizeLimit: number\r\n  }\r\n}\r\n\r\ninterface PerformanceReport {\r\n  timestamp: string\r\n  url: string\r\n  metrics: PerformanceMetrics\r\n  userAgent: string\r\n  viewport: {\r\n    width: number\r\n    height: number\r\n  }\r\n}\r\n\r\nclass PerformanceMonitor {\r\n  private reports: PerformanceReport[] = []\r\n  private isMonitoring = false\r\n\r\n  startMonitoring() {\r\n    if (this.isMonitoring) return\r\n\r\n    this.isMonitoring = true\r\n    this.observePerformanceMetrics()\r\n    this.observeUserInteractions()\r\n    this.observeMemoryUsage()\r\n\r\n    console.log(\"🔍 성능 모니터링이 시작되었습니다.\")\r\n  }\r\n\r\n  stopMonitoring() {\r\n    this.isMonitoring = false\r\n    console.log(\"🔍 성능 모니터링이 중지되었습니다.\")\r\n  }\r\n\r\n  private observePerformanceMetrics() {\r\n    // 페이지 로드 성능 측정\r\n    window.addEventListener(\"load\", () => {\r\n      const navigation = performance.getEntriesByType(\r\n        \"navigation\"\r\n      )[0] as PerformanceNavigationTiming\r\n      const paint = performance.getEntriesByType(\"paint\")\r\n\r\n      const metrics: PerformanceMetrics = {\r\n        pageLoadTime: navigation.loadEventEnd - navigation.loadEventStart,\r\n        domContentLoaded:\r\n          navigation.domContentLoadedEventEnd -\r\n          navigation.domContentLoadedEventStart,\r\n        firstContentfulPaint:\r\n          paint.find(entry => entry.name === \"first-contentful-paint\")\r\n            ?.startTime || 0,\r\n        largestContentfulPaint: 0,\r\n        firstInputDelay: 0,\r\n        cumulativeLayoutShift: 0,\r\n      }\r\n\r\n      // Largest Contentful Paint 측정\r\n      if (\"PerformanceObserver\" in window) {\r\n        const lcpObserver = new PerformanceObserver(list => {\r\n          const entries = list.getEntries()\r\n          const lastEntry = entries[entries.length - 1]\r\n          metrics.largestContentfulPaint = lastEntry.startTime\r\n        })\r\n        lcpObserver.observe({ entryTypes: [\"largest-contentful-paint\"] })\r\n      }\r\n\r\n      // First Input Delay 측정\r\n      if (\"PerformanceObserver\" in window) {\r\n        const fidObserver = new PerformanceObserver(list => {\r\n          const entries = list.getEntries()\r\n          const firstEntry = entries[0] as PerformanceInputTiming\r\n          metrics.firstInputDelay =\r\n            firstEntry.processingStart - firstEntry.startTime\r\n        })\r\n        fidObserver.observe({ entryTypes: [\"first-input\"] })\r\n      }\r\n\r\n      // Cumulative Layout Shift 측정\r\n      if (\"PerformanceObserver\" in window) {\r\n        const clsObserver = new PerformanceObserver(list => {\r\n          let clsValue = 0\r\n          for (const entry of list.getEntries()) {\r\n            const layoutShiftEntry = entry as PerformanceLayoutShift\r\n            if (!layoutShiftEntry.hadRecentInput) {\r\n              clsValue += layoutShiftEntry.value\r\n            }\r\n          }\r\n          metrics.cumulativeLayoutShift = clsValue\r\n        })\r\n        clsObserver.observe({ entryTypes: [\"layout-shift\"] })\r\n      }\r\n\r\n      this.recordMetrics(metrics)\r\n    })\r\n  }\r\n\r\n  private observeUserInteractions() {\r\n    // 사용자 상호작용 성능 측정\r\n    let firstInteraction = true\r\n\r\n    const interactionTypes = [\"click\", \"keydown\", \"scroll\", \"touchstart\"]\r\n\r\n    interactionTypes.forEach(type => {\r\n      document.addEventListener(\r\n        type,\r\n        event => {\r\n          if (firstInteraction) {\r\n            const now = performance.now()\r\n            const navigation = performance.getEntriesByType(\r\n              \"navigation\"\r\n            )[0] as PerformanceNavigationTiming\r\n            const firstInputDelay = now - navigation.loadEventEnd\r\n\r\n            this.recordMetrics({\r\n              pageLoadTime: 0,\r\n              domContentLoaded: 0,\r\n              firstContentfulPaint: 0,\r\n              largestContentfulPaint: 0,\r\n              firstInputDelay,\r\n              cumulativeLayoutShift: 0,\r\n            })\r\n\r\n            firstInteraction = false\r\n          }\r\n        },\r\n        { once: true }\r\n      )\r\n    })\r\n  }\r\n\r\n  private observeMemoryUsage() {\r\n    // 메모리 사용량 모니터링 (Chrome에서만 사용 가능)\r\n    if (\"memory\" in performance) {\r\n      setInterval(() => {\r\n        const memory = (\r\n          performance as Performance & { memory: PerformanceMemory }\r\n        ).memory\r\n        this.recordMetrics({\r\n          pageLoadTime: 0,\r\n          domContentLoaded: 0,\r\n          firstContentfulPaint: 0,\r\n          largestContentfulPaint: 0,\r\n          firstInputDelay: 0,\r\n          cumulativeLayoutShift: 0,\r\n          memoryUsage: {\r\n            usedJSHeapSize: memory.usedJSHeapSize,\r\n            totalJSHeapSize: memory.totalJSHeapSize,\r\n            jsHeapSizeLimit: memory.jsHeapSizeLimit,\r\n          },\r\n        })\r\n      }, 30000) // 30초마다 측정\r\n    }\r\n  }\r\n\r\n  private recordMetrics(metrics: PerformanceMetrics) {\r\n    const report: PerformanceReport = {\r\n      timestamp: new Date().toISOString(),\r\n      url: window.location.href,\r\n      metrics,\r\n      userAgent: navigator.userAgent,\r\n      viewport: {\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n      },\r\n    }\r\n\r\n    this.reports.push(report)\r\n    this.analyzePerformance(report)\r\n  }\r\n\r\n  private analyzePerformance(report: PerformanceReport) {\r\n    const { metrics } = report\r\n    const warnings: string[] = []\r\n\r\n    // 성능 임계값 체크\r\n    if (metrics.pageLoadTime > 3000) {\r\n      warnings.push(\"페이지 로드 시간이 3초를 초과합니다.\")\r\n    }\r\n\r\n    if (metrics.firstContentfulPaint > 2000) {\r\n      warnings.push(\"First Contentful Paint가 2초를 초과합니다.\")\r\n    }\r\n\r\n    if (metrics.largestContentfulPaint > 2500) {\r\n      warnings.push(\"Largest Contentful Paint가 2.5초를 초과합니다.\")\r\n    }\r\n\r\n    if (metrics.firstInputDelay > 100) {\r\n      warnings.push(\"First Input Delay가 100ms를 초과합니다.\")\r\n    }\r\n\r\n    if (metrics.cumulativeLayoutShift > 0.1) {\r\n      warnings.push(\"Cumulative Layout Shift가 0.1을 초과합니다.\")\r\n    }\r\n\r\n    if (\r\n      metrics.memoryUsage &&\r\n      metrics.memoryUsage.usedJSHeapSize > 50 * 1024 * 1024\r\n    ) {\r\n      warnings.push(\"메모리 사용량이 50MB를 초과합니다.\")\r\n    }\r\n\r\n    if (warnings.length > 0) {\r\n      console.warn(\"⚠️ 성능 경고:\", warnings)\r\n    }\r\n  }\r\n\r\n  getReports(): PerformanceReport[] {\r\n    return this.reports\r\n  }\r\n\r\n  getLatestReport(): PerformanceReport | null {\r\n    return this.reports[this.reports.length - 1] || null\r\n  }\r\n\r\n  clearReports() {\r\n    this.reports = []\r\n  }\r\n\r\n  exportReports(): string {\r\n    return JSON.stringify(this.reports, null, 2)\r\n  }\r\n\r\n  // API로 성능 데이터 전송\r\n  async sendPerformanceData(endpoint: string) {\r\n    try {\r\n      const response = await fetch(endpoint, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          reports: this.reports,\r\n          timestamp: new Date().toISOString(),\r\n        }),\r\n      })\r\n\r\n      if (response.ok) {\r\n        console.log(\"📊 성능 데이터가 성공적으로 전송되었습니다.\")\r\n        this.clearReports()\r\n      } else {\r\n        console.error(\"❌ 성능 데이터 전송 실패:\", response.statusText)\r\n      }\r\n    } catch (error) {\r\n      console.error(\"❌ 성능 데이터 전송 중 오류:\", error)\r\n    }\r\n  }\r\n}\r\n\r\n// 싱글톤 인스턴스\r\nexport const performanceMonitor = new PerformanceMonitor()\r\n\r\n// 자동 시작 (개발 환경에서만)\r\nif (process.env.DEV) {\r\n  performanceMonitor.startMonitoring()\r\n}\r\n","timestamp":1759820789754}