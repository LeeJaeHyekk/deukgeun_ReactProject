{"key":"efe82316a4420c1685a173e4651fdcf4","result":"// Browser API polyfills for Node.js environment\nif (typeof window === 'undefined') {\n  global.window = global.window || {}\n  global.document = global.document || {}\n  global.localStorage = global.localStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.sessionStorage = global.sessionStorage || {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n    clear: () => {}\n  }\n  global.File = global.File || class File {}\n  global.StorageEvent = global.StorageEvent || class StorageEvent {}\n  global.requestAnimationFrame = global.requestAnimationFrame || (cb => setTimeout(cb, 16))\n}\n\n// Performance API íƒ€ì… í™•ì¥\r\ninterface PerformanceNavigationTiming extends PerformanceEntry {\r\n  loadEventEnd: number\r\n  loadEventStart: number\r\n  domContentLoadedEventEnd: number\r\n  domContentLoadedEventStart: number\r\n}\r\n\r\ninterface PerformancePaintTiming extends PerformanceEntry {\r\n  name: string\r\n  startTime: number\r\n}\r\n\r\ninterface PerformanceInputTiming extends PerformanceEntry {\r\n  processingStart: number\r\n  startTime: number\r\n}\r\n\r\ninterface PerformanceLayoutShift extends PerformanceEntry {\r\n  value: number\r\n  hadRecentInput: boolean\r\n}\r\n\r\ninterface PerformanceMemory {\r\n  usedJSHeapSize: number\r\n  totalJSHeapSize: number\r\n  jsHeapSizeLimit: number\r\n}\r\n\r\ninterface PerformanceMetrics {\r\n  pageLoadTime: number\r\n  domContentLoaded: number\r\n  firstContentfulPaint: number\r\n  largestContentfulPaint: number\r\n  firstInputDelay: number\r\n  cumulativeLayoutShift: number\r\n  memoryUsage?: {\r\n    usedJSHeapSize: number\r\n    totalJSHeapSize: number\r\n    jsHeapSizeLimit: number\r\n  }\r\n}\r\n\r\ninterface PerformanceReport {\r\n  timestamp: string\r\n  url: string\r\n  metrics: PerformanceMetrics\r\n  userAgent: string\r\n  viewport: {\r\n    width: number\r\n    height: number\r\n  }\r\n}\r\n\r\nclass PerformanceMonitor {\r\n  private reports: PerformanceReport[] = []\r\n  private isMonitoring = false\r\n\r\n  startMonitoring() {\r\n    if (this.isMonitoring) return\r\n\r\n    this.isMonitoring = true\r\n    this.observePerformanceMetrics()\r\n    this.observeUserInteractions()\r\n    this.observeMemoryUsage()\r\n\r\n    console.log(\"ğŸ” ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.\")\r\n  }\r\n\r\n  stopMonitoring() {\r\n    this.isMonitoring = false\r\n    console.log(\"ğŸ” ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.\")\r\n  }\r\n\r\n  private observePerformanceMetrics() {\r\n    // í˜ì´ì§€ ë¡œë“œ ì„±ëŠ¥ ì¸¡ì •\r\n    window.addEventListener(\"load\", () => {\r\n      const navigation = performance.getEntriesByType(\r\n        \"navigation\"\r\n      )[0] as PerformanceNavigationTiming\r\n      const paint = performance.getEntriesByType(\"paint\")\r\n\r\n      const metrics: PerformanceMetrics = {\r\n        pageLoadTime: navigation.loadEventEnd - navigation.loadEventStart,\r\n        domContentLoaded:\r\n          navigation.domContentLoadedEventEnd -\r\n          navigation.domContentLoadedEventStart,\r\n        firstContentfulPaint:\r\n          paint.find(entry => entry.name === \"first-contentful-paint\")\r\n            ?.startTime || 0,\r\n        largestContentfulPaint: 0,\r\n        firstInputDelay: 0,\r\n        cumulativeLayoutShift: 0,\r\n      }\r\n\r\n      // Largest Contentful Paint ì¸¡ì •\r\n      if (\"PerformanceObserver\" in window) {\r\n        const lcpObserver = new PerformanceObserver(list => {\r\n          const entries = list.getEntries()\r\n          const lastEntry = entries[entries.length - 1]\r\n          metrics.largestContentfulPaint = lastEntry.startTime\r\n        })\r\n        lcpObserver.observe({ entryTypes: [\"largest-contentful-paint\"] })\r\n      }\r\n\r\n      // First Input Delay ì¸¡ì •\r\n      if (\"PerformanceObserver\" in window) {\r\n        const fidObserver = new PerformanceObserver(list => {\r\n          const entries = list.getEntries()\r\n          const firstEntry = entries[0] as PerformanceInputTiming\r\n          metrics.firstInputDelay =\r\n            firstEntry.processingStart - firstEntry.startTime\r\n        })\r\n        fidObserver.observe({ entryTypes: [\"first-input\"] })\r\n      }\r\n\r\n      // Cumulative Layout Shift ì¸¡ì •\r\n      if (\"PerformanceObserver\" in window) {\r\n        const clsObserver = new PerformanceObserver(list => {\r\n          let clsValue = 0\r\n          for (const entry of list.getEntries()) {\r\n            const layoutShiftEntry = entry as PerformanceLayoutShift\r\n            if (!layoutShiftEntry.hadRecentInput) {\r\n              clsValue += layoutShiftEntry.value\r\n            }\r\n          }\r\n          metrics.cumulativeLayoutShift = clsValue\r\n        })\r\n        clsObserver.observe({ entryTypes: [\"layout-shift\"] })\r\n      }\r\n\r\n      this.recordMetrics(metrics)\r\n    })\r\n  }\r\n\r\n  private observeUserInteractions() {\r\n    // ì‚¬ìš©ì ìƒí˜¸ì‘ìš© ì„±ëŠ¥ ì¸¡ì •\r\n    let firstInteraction = true\r\n\r\n    const interactionTypes = [\"click\", \"keydown\", \"scroll\", \"touchstart\"]\r\n\r\n    interactionTypes.forEach(type => {\r\n      document.addEventListener(\r\n        type,\r\n        event => {\r\n          if (firstInteraction) {\r\n            const now = performance.now()\r\n            const navigation = performance.getEntriesByType(\r\n              \"navigation\"\r\n            )[0] as PerformanceNavigationTiming\r\n            const firstInputDelay = now - navigation.loadEventEnd\r\n\r\n            this.recordMetrics({\r\n              pageLoadTime: 0,\r\n              domContentLoaded: 0,\r\n              firstContentfulPaint: 0,\r\n              largestContentfulPaint: 0,\r\n              firstInputDelay,\r\n              cumulativeLayoutShift: 0,\r\n            })\r\n\r\n            firstInteraction = false\r\n          }\r\n        },\r\n        { once: true }\r\n      )\r\n    })\r\n  }\r\n\r\n  private observeMemoryUsage() {\r\n    // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ (Chromeì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥)\r\n    if (\"memory\" in performance) {\r\n      setInterval(() => {\r\n        const memory = (\r\n          performance as Performance & { memory: PerformanceMemory }\r\n        ).memory\r\n        this.recordMetrics({\r\n          pageLoadTime: 0,\r\n          domContentLoaded: 0,\r\n          firstContentfulPaint: 0,\r\n          largestContentfulPaint: 0,\r\n          firstInputDelay: 0,\r\n          cumulativeLayoutShift: 0,\r\n          memoryUsage: {\r\n            usedJSHeapSize: memory.usedJSHeapSize,\r\n            totalJSHeapSize: memory.totalJSHeapSize,\r\n            jsHeapSizeLimit: memory.jsHeapSizeLimit,\r\n          },\r\n        })\r\n      }, 30000) // 30ì´ˆë§ˆë‹¤ ì¸¡ì •\r\n    }\r\n  }\r\n\r\n  private recordMetrics(metrics: PerformanceMetrics) {\r\n    const report: PerformanceReport = {\r\n      timestamp: new Date().toISOString(),\r\n      url: window.location.href,\r\n      metrics,\r\n      userAgent: navigator.userAgent,\r\n      viewport: {\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n      },\r\n    }\r\n\r\n    this.reports.push(report)\r\n    this.analyzePerformance(report)\r\n  }\r\n\r\n  private analyzePerformance(report: PerformanceReport) {\r\n    const { metrics } = report\r\n    const warnings: string[] = []\r\n\r\n    // ì„±ëŠ¥ ì„ê³„ê°’ ì²´í¬\r\n    if (metrics.pageLoadTime > 3000) {\r\n      warnings.push(\"í˜ì´ì§€ ë¡œë“œ ì‹œê°„ì´ 3ì´ˆë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.\")\r\n    }\r\n\r\n    if (metrics.firstContentfulPaint > 2000) {\r\n      warnings.push(\"First Contentful Paintê°€ 2ì´ˆë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.\")\r\n    }\r\n\r\n    if (metrics.largestContentfulPaint > 2500) {\r\n      warnings.push(\"Largest Contentful Paintê°€ 2.5ì´ˆë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.\")\r\n    }\r\n\r\n    if (metrics.firstInputDelay > 100) {\r\n      warnings.push(\"First Input Delayê°€ 100msë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.\")\r\n    }\r\n\r\n    if (metrics.cumulativeLayoutShift > 0.1) {\r\n      warnings.push(\"Cumulative Layout Shiftê°€ 0.1ì„ ì´ˆê³¼í•©ë‹ˆë‹¤.\")\r\n    }\r\n\r\n    if (\r\n      metrics.memoryUsage &&\r\n      metrics.memoryUsage.usedJSHeapSize > 50 * 1024 * 1024\r\n    ) {\r\n      warnings.push(\"ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ 50MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.\")\r\n    }\r\n\r\n    if (warnings.length > 0) {\r\n      console.warn(\"âš ï¸ ì„±ëŠ¥ ê²½ê³ :\", warnings)\r\n    }\r\n  }\r\n\r\n  getReports(): PerformanceReport[] {\r\n    return this.reports\r\n  }\r\n\r\n  getLatestReport(): PerformanceReport | null {\r\n    return this.reports[this.reports.length - 1] || null\r\n  }\r\n\r\n  clearReports() {\r\n    this.reports = []\r\n  }\r\n\r\n  exportReports(): string {\r\n    return JSON.stringify(this.reports, null, 2)\r\n  }\r\n\r\n  // APIë¡œ ì„±ëŠ¥ ë°ì´í„° ì „ì†¡\r\n  async sendPerformanceData(endpoint: string) {\r\n    try {\r\n      const response = await fetch(endpoint, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          reports: this.reports,\r\n          timestamp: new Date().toISOString(),\r\n        }),\r\n      })\r\n\r\n      if (response.ok) {\r\n        console.log(\"ğŸ“Š ì„±ëŠ¥ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.\")\r\n        this.clearReports()\r\n      } else {\r\n        console.error(\"âŒ ì„±ëŠ¥ ë°ì´í„° ì „ì†¡ ì‹¤íŒ¨:\", response.statusText)\r\n      }\r\n    } catch (error) {\r\n      console.error(\"âŒ ì„±ëŠ¥ ë°ì´í„° ì „ì†¡ ì¤‘ ì˜¤ë¥˜:\", error)\r\n    }\r\n  }\r\n}\r\n\r\n// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤\r\nexport const performanceMonitor = new PerformanceMonitor()\r\n\r\n// ìë™ ì‹œì‘ (ê°œë°œ í™˜ê²½ì—ì„œë§Œ)\r\nif (process.env.DEV) {\r\n  performanceMonitor.startMonitoring()\r\n}\r\n","timestamp":1759820789754}