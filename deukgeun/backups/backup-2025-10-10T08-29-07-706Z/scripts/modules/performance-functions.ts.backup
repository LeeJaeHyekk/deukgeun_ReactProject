/**
 * 성능 최적화 함수 모듈
 * 메모리 관리, 병렬 처리, 캐싱 등의 성능 최적화 기능 제공
 */

import * as os from 'os'
import * as fs from 'fs'
import * as path from 'path'
import { logInfo, logWarning, logError } from './logger-functions'

// 성능 메트릭 인터페이스
export interface PerformanceMetrics {
  memoryUsage: {
    heapUsed: number
    heapTotal: number
    external: number
    rss: number
  }
  cpuUsage: {
    user: number
    system: number
  }
  systemResources: {
    totalMemory: number
    freeMemory: number
    cpuCount: number
    loadAverage: number[]
  }
  timestamp: string
}

// 병렬 처리 옵션
export interface ParallelOptions {
  maxWorkers: number
  timeout: number
  retryCount: number
  retryDelay: number
}

// 캐시 옵션
export interface CacheOptions {
  maxSize: number
  ttl: number
  compression: boolean
}

// 성능 모니터링 클래스
export class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = []
  private startTime: number = 0
  private maxMetrics: number = 100

  constructor() {
    this.startTime = Date.now()
  }

  /**
   * 현재 성능 메트릭 수집
   */
  collectMetrics(): PerformanceMetrics {
    const memoryUsage = process.memoryUsage()
    const cpuUsage = process.cpuUsage()
    const systemResources = {
      totalMemory: os.totalmem(),
      freeMemory: os.freemem(),
      cpuCount: os.cpus().length,
      loadAverage: os.loadavg()
    }

    const metrics: PerformanceMetrics = {
      memoryUsage,
      cpuUsage: {
        user: cpuUsage.user / 1000000, // 마이크로초를 초로 변환
        system: cpuUsage.system / 1000000
      },
      systemResources,
      timestamp: new Date().toISOString()
    }

    this.metrics.push(metrics)
    
    // 메트릭 수 제한
    if (this.metrics.length > this.maxMetrics) {
      this.metrics = this.metrics.slice(-this.maxMetrics)
    }

    return metrics
  }

  /**
   * 메모리 사용량 확인
   */
  checkMemoryUsage(): boolean {
    const metrics = this.collectMetrics()
    const heapUsedMB = metrics.memoryUsage.heapUsed / 1024 / 1024
    const maxMemoryMB = 1024 // 1GB 제한

    if (heapUsedMB > maxMemoryMB) {
      logWarning(`높은 메모리 사용량: ${heapUsedMB.toFixed(2)}MB`)
      return false
    }

    return true
  }

  /**
   * CPU 사용량 확인
   */
  checkCPUUsage(): boolean {
    const metrics = this.collectMetrics()
    const loadAverage = metrics.systemResources.loadAverage[0]
    const cpuCount = metrics.systemResources.cpuCount

    if (loadAverage > cpuCount * 0.8) {
      logWarning(`높은 CPU 사용량: ${loadAverage.toFixed(2)} (${cpuCount} 코어)`)
      return false
    }

    return true
  }

  /**
   * 성능 통계 생성
   */
  generateStats(): {
    averageMemory: number
    peakMemory: number
    averageCPU: number
    peakCPU: number
    duration: number
  } {
    if (this.metrics.length === 0) {
      return {
        averageMemory: 0,
        peakMemory: 0,
        averageCPU: 0,
        peakCPU: 0,
        duration: 0
      }
    }

    const memoryUsages = this.metrics.map(m => m.memoryUsage.heapUsed / 1024 / 1024)
    const cpuUsages = this.metrics.map(m => m.cpuUsage.user + m.cpuUsage.system)

    return {
      averageMemory: memoryUsages.reduce((sum, usage) => sum + usage, 0) / memoryUsages.length,
      peakMemory: Math.max(...memoryUsages),
      averageCPU: cpuUsages.reduce((sum, usage) => sum + usage, 0) / cpuUsages.length,
      peakCPU: Math.max(...cpuUsages),
      duration: Date.now() - this.startTime
    }
  }

  /**
   * 메모리 정리
   */
  forceGC(): void {
    if ((global as any).gc) {
      (global as any).gc()
      logInfo('메모리 정리 실행됨')
    } else {
      logWarning('GC가 활성화되지 않았습니다. --expose-gc 플래그를 사용하세요.')
    }
  }
}

// 병렬 처리 관리자
export class ParallelProcessor {
  private maxWorkers: number
  private activeWorkers: number = 0
  private queue: Array<() => Promise<any>> = []
  private results: any[] = []
  private errors: Error[] = []

  constructor(maxWorkers: number = os.cpus().length) {
    this.maxWorkers = Math.min(maxWorkers, os.cpus().length)
  }

  /**
   * 병렬 작업 실행
   */
  async process<T>(
    tasks: Array<() => Promise<T>>,
    options: Partial<ParallelOptions> = {}
  ): Promise<T[]> {
    const finalOptions: ParallelOptions = {
      maxWorkers: this.maxWorkers,
      timeout: 300000, // 5분
      retryCount: 3,
      retryDelay: 2000,
      ...options
    }

    this.queue = [...tasks]
    this.results = []
    this.errors = []

    logInfo(`병렬 처리 시작: ${tasks.length}개 작업, ${finalOptions.maxWorkers}개 워커`)

    // 워커 실행
    const workerPromises = Array.from({ length: finalOptions.maxWorkers }, () =>
      this.runWorker(finalOptions)
    )

    await Promise.all(workerPromises)

    if (this.errors.length > 0) {
      logError(`병렬 처리 중 ${this.errors.length}개 오류 발생`)
      throw new Error(`병렬 처리 실패: ${this.errors.map(e => e.message).join(', ')}`)
    }

    return this.results as T[]
  }

  /**
   * 워커 실행
   */
  private async runWorker(options: ParallelOptions): Promise<void> {
    while (this.queue.length > 0) {
      const task = this.queue.shift()
      if (!task) break

      this.activeWorkers++
      try {
        const result = await this.executeWithRetry(task, options)
        this.results.push(result)
      } catch (error) {
        this.errors.push(error as Error)
      } finally {
        this.activeWorkers--
      }
    }
  }

  /**
   * 재시도와 함께 작업 실행
   */
  private async executeWithRetry<T>(
    task: () => Promise<T>,
    options: ParallelOptions
  ): Promise<T> {
    let lastError: Error | null = null

    for (let attempt = 1; attempt <= options.retryCount; attempt++) {
      try {
        return await Promise.race([
          task(),
          new Promise<never>((_, reject) => 
            setTimeout(() => reject(new Error('작업 타임아웃')), options.timeout)
          )
        ])
      } catch (error) {
        lastError = error as Error
        
        if (attempt < options.retryCount) {
          logWarning(`작업 실패 (시도 ${attempt}/${options.retryCount}): ${lastError.message`)
          await new Promise(resolve => setTimeout(resolve, options.retryDelay))
        }
      }
    }

    throw lastError || new Error('작업 실행 실패')
  }
}

// 캐시 관리자
export class CacheManager {
  private cache: Map<string, { data: any; timestamp: number; ttl: number }> = new Map()
  private maxSize: number
  private defaultTTL: number

  constructor(options: Partial<CacheOptions> = {}) {
    this.maxSize = options.maxSize || 1000
    this.defaultTTL = options.ttl || 300000 // 5분
  }

  /**
   * 캐시에서 데이터 가져오기
   */
  get<T>(key: string): T | null {
    const item = this.cache.get(key)
    
    if (!item) {
      return null
    }

    // TTL 확인
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key)
      return null
    }

    return item.data as T
  }

  /**
   * 캐시에 데이터 저장
   */
  set<T>(key: string, data: T, ttl?: number): void {
    // 캐시 크기 제한
    if (this.cache.size >= this.maxSize) {
      this.evictOldest()
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttl || this.defaultTTL
    })
  }

  /**
   * 캐시에서 데이터 삭제
   */
  delete(key: string): boolean {
    return this.cache.delete(key)
  }

  /**
   * 캐시 비우기
   */
  clear(): void {
    this.cache.clear()
  }

  /**
   * 가장 오래된 항목 제거
   */
  private evictOldest(): void {
    let oldestKey: string | null = null
    let oldestTime = Date.now()

    for (const [key, item] of this.cache.entries()) {
      if (item.timestamp < oldestTime) {
        oldestTime = item.timestamp
        oldestKey = key
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey)
    }
  }

  /**
   * 캐시 통계
   */
  getStats(): {
    size: number
    maxSize: number
    hitRate: number
    memoryUsage: number
  } {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: 0, // TODO: 히트율 계산 구현
      memoryUsage: process.memoryUsage().heapUsed
    }
  }
}

// 파일 처리 최적화
export class FileProcessor {
  private cache: CacheManager
  private processor: ParallelProcessor

  constructor() {
    this.cache = new CacheManager({ maxSize: 500, ttl: 600000 }) // 10분
    this.processor = new ParallelProcessor()
  }

  /**
   * 파일 배치 처리
   */
  async processFiles<T>(
    files: string[],
    processor: (filePath: string) => Promise<T>,
    options: Partial<ParallelOptions> = {}
  ): Promise<{ results: T[]; errors: Error[] }> {
    const tasks = files.map(filePath => async () => {
      // 캐시 확인
      const cacheKey = `file:${filePath}:${fs.statSync(filePath).mtime.getTime()}`
      const cached = this.cache.get<T>(cacheKey)
      
      if (cached) {
        return cached
      }

      // 파일 처리
      const result = await processor(filePath)
      
      // 캐시 저장
      this.cache.set(cacheKey, result)
      
      return result
    })

    try {
      const results = await this.processor.process(tasks, options)
      return { results, errors: [] }
    } catch (error) {
      return { results: [], errors: [error as Error] }
    }
  }

  /**
   * 디렉토리 스캔 최적화
   */
  async scanDirectory(
    dirPath: string,
    options: {
      recursive?: boolean
      includeFiles?: boolean
      includeDirs?: boolean
      extensions?: string[]
      maxDepth?: number
    } = {}
  ): Promise<string[]> {
    const cacheKey = `scan:${dirPath}:${options}`
    const cached = this.cache.get<string[]>(cacheKey)
    
    if (cached) {
      return cached
    }

    const results: string[] = []
    const scanOptions = {
      recursive: true,
      includeFiles: true,
      includeDirs: false,
      extensions: [],
      maxDepth: 10,
      ...options
    }

    const scan = (currentPath: string, depth: number = 0): void => {
      if (scanOptions.maxDepth && depth >= scanOptions.maxDepth) {
        return
      }

      try {
        const items = fs.readdirSync(currentPath)
        
        for (const item of items) {
          const fullPath = path.join(currentPath, item)
          const stat = fs.statSync(fullPath)
          
          if (stat.isDirectory()) {
            if (scanOptions.includeDirs) {
              results.push(fullPath)
            }
            if (scanOptions.recursive) {
              scan(fullPath, depth + 1)
            }
          } else if (stat.isFile()) {
            if (scanOptions.includeFiles) {
              if (scanOptions.extensions.length === 0 || 
                  scanOptions.extensions.some(ext => fullPath.endsWith(ext))) {
                results.push(fullPath)
              }
            }
          }
        }
      } catch (error) {
        // 권한 오류 등은 무시
      }
    }

    scan(dirPath)
    
    // 캐시 저장
    this.cache.set(cacheKey, results)
    
    return results
  }
}

// 성능 최적화 유틸리티 함수들
export const performanceUtils = {
  /**
   * 최적 워커 수 계산
   */
  getOptimalWorkerCount(): number {
    const cpuCount = os.cpus().length
    const memoryGB = os.totalmem() / (1024 * 1024 * 1024)
    
    // CPU 기반 계산
    let workers = Math.max(1, Math.floor(cpuCount * 0.8))
    
    // 메모리 기반 조정
    if (memoryGB < 4) {
      workers = Math.min(workers, 2)
    } else if (memoryGB < 8) {
      workers = Math.min(workers, 4)
    }
    
    return workers
  },

  /**
   * 메모리 사용량 최적화
   */
  optimizeMemory(): void {
    if ((global as any).gc) {
      (global as any).gc()
    }
    
    // 불필요한 참조 정리
    if (global.gc) {
      global.gc()
    }
  },

  /**
   * 시스템 리소스 확인
   */
  checkSystemResources(): {
    available: boolean
    memory: boolean
    cpu: boolean
    disk: boolean
  } {
    const memoryUsage = process.memoryUsage()
    const systemMemory = os.freemem()
    const loadAverage = os.loadavg()[0]
    const cpuCount = os.cpus().length

    return {
      available: true,
      memory: systemMemory > 100 * 1024 * 1024, // 100MB 이상
      cpu: loadAverage < cpuCount * 0.9, // 90% 미만
      disk: true // TODO: 디스크 공간 확인 구현
    }
  }
}
