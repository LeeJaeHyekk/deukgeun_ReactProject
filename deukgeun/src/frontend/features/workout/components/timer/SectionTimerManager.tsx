import React, { useState, useEffect, useCallback, useMemo } from "react"
import { Play, Pause, Square, RotateCcw } from "lucide-react"
import type { SectionTimerState, AutoGeneratedSection } from "../../types"
import "./SectionTimerManager.css"

interface SectionTimerManagerProps {
  section: AutoGeneratedSection
  timerState: SectionTimerState
  onStart: (sectionId: number) => void
  onPause: (sectionId: number) => void
  onComplete: (sectionId: number) => void
  onReset: (sectionId: number) => void
  isActive: boolean
  className?: string
}

// 로깅 유틸리티
const logger = {
  info: (message: string, data?: any) => {
    console.log(`[SectionTimerManager] ${message}`, data || "")
  },
  debug: (message: string, data?: any) => {
    console.debug(`[SectionTimerManager] ${message}`, data || "")
  },
  warn: (message: string, data?: any) => {
    console.warn(`[SectionTimerManager] ${message}`, data || "")
  },
  error: (message: string, error?: any) => {
    console.error(`[SectionTimerManager] ${message}`, error || "")
  },
}

export function SectionTimerManager({
  section,
  timerState,
  onStart,
  onPause,
  onComplete,
  onReset,
  isActive,
  className = "",
}: SectionTimerManagerProps) {
  const [localElapsedTime, setLocalElapsedTime] = useState(
    timerState.elapsedTime
  )
  const [animationId, setAnimationId] = useState<number | null>(null)

  // 시간 포맷팅 함수
  const formatTime = useCallback((seconds: number): string => {
    const hours = Math.floor(seconds / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)
    const secs = seconds % 60

    if (hours > 0) {
      return `${hours.toString().padStart(2, "0")}:${minutes
        .toString()
        .padStart(2, "0")}:${secs.toString().padStart(2, "0")}`
    }
    return `${minutes.toString().padStart(2, "0")}:${secs
      .toString()
      .padStart(2, "0")}`
  }, [])

  // 진행률 계산
  const progress = useMemo(() => {
    if (timerState.totalTime === 0) return 0
    return Math.min((localElapsedTime / timerState.totalTime) * 100, 100)
  }, [localElapsedTime, timerState.totalTime])

  // 타이머 애니메이션
  const startTimerAnimation = useCallback(() => {
    if (animationId) return

    const startTime = performance.now()
    const initialElapsedTime = localElapsedTime

    const animate = (currentTime: number) => {
      const elapsed = Math.floor((currentTime - startTime) / 1000)
      const newElapsedTime = initialElapsedTime + elapsed

      setLocalElapsedTime(newElapsedTime)

      if (timerState.isRunning && !timerState.isPaused) {
        const newAnimationId = requestAnimationFrame(animate)
        setAnimationId(newAnimationId)
      }
    }

    const newAnimationId = requestAnimationFrame(animate)
    setAnimationId(newAnimationId)
  }, [animationId, localElapsedTime, timerState.isRunning, timerState.isPaused])

  // 타이머 정지
  const stopTimerAnimation = useCallback(() => {
    if (animationId) {
      cancelAnimationFrame(animationId)
      setAnimationId(null)
    }
  }, [animationId])

  // 타이머 상태 변경 감지
  useEffect(() => {
    setLocalElapsedTime(timerState.elapsedTime)
  }, [timerState.elapsedTime])

  // 타이머 실행/정지 관리
  useEffect(() => {
    if (timerState.isRunning && !timerState.isPaused) {
      startTimerAnimation()
    } else {
      stopTimerAnimation()
    }

    return () => {
      stopTimerAnimation()
    }
  }, [
    timerState.isRunning,
    timerState.isPaused,
    startTimerAnimation,
    stopTimerAnimation,
  ])

  // 컴포넌트 언마운트 시 정리
  useEffect(() => {
    return () => {
      stopTimerAnimation()
    }
  }, [stopTimerAnimation])

  // 이벤트 핸들러들
  const handleStart = useCallback(() => {
    logger.info("타이머 시작", {
      sectionId: section.id,
      exerciseName: section.exerciseName,
    })
    onStart(section.id)
  }, [section.id, section.exerciseName, onStart])

  const handlePause = useCallback(() => {
    logger.info("타이머 일시정지", {
      sectionId: section.id,
      exerciseName: section.exerciseName,
    })
    onPause(section.id)
  }, [section.id, section.exerciseName, onPause])

  const handleComplete = useCallback(() => {
    logger.info("섹션 완료", {
      sectionId: section.id,
      exerciseName: section.exerciseName,
    })
    onComplete(section.id)
  }, [section.id, section.exerciseName, onComplete])

  const handleReset = useCallback(() => {
    logger.info("타이머 리셋", {
      sectionId: section.id,
      exerciseName: section.exerciseName,
    })
    onReset(section.id)
  }, [section.id, section.exerciseName, onReset])

  return (
    <div
      className={`section-timer-manager ${className} ${isActive ? "active" : ""}`}
    >
      <div className="timer-header">
        <h4 className="exercise-name">{section.exerciseName}</h4>
        <div className="section-info">
          <span className="sets-reps">
            {section.sets}세트 × {section.reps}회
          </span>
          {section.weight && section.weight > 0 && (
            <span className="weight">{section.weight}kg</span>
          )}
        </div>
      </div>

      <div className="timer-display">
        <div className="time-display">
          <span className="elapsed-time">{formatTime(localElapsedTime)}</span>
          {timerState.totalTime > 0 && (
            <span className="total-time">
              / {formatTime(timerState.totalTime)}
            </span>
          )}
        </div>

        <div className="progress-bar">
          <div className="progress-fill" style={{ width: `${progress}%` }} />
        </div>
      </div>

      <div className="timer-controls">
        {!timerState.isRunning ? (
          <button
            className="control-btn start-btn"
            onClick={handleStart}
            disabled={!isActive}
            aria-label="타이머 시작"
          >
            <Play size={16} />
            시작
          </button>
        ) : timerState.isPaused ? (
          <button
            className="control-btn resume-btn"
            onClick={handleStart}
            aria-label="타이머 재개"
          >
            <Play size={16} />
            재개
          </button>
        ) : (
          <button
            className="control-btn pause-btn"
            onClick={handlePause}
            aria-label="타이머 일시정지"
          >
            <Pause size={16} />
            일시정지
          </button>
        )}

        <button
          className="control-btn complete-btn"
          onClick={handleComplete}
          disabled={!timerState.isRunning}
          aria-label="섹션 완료"
        >
          <Square size={16} />
          완료
        </button>

        <button
          className="control-btn reset-btn"
          onClick={handleReset}
          aria-label="타이머 리셋"
        >
          <RotateCcw size={16} />
          리셋
        </button>
      </div>

      <div className="section-status">
        <span
          className={`status-indicator ${section.isCompleted ? "completed" : "in-progress"}`}
        >
          {section.isCompleted ? "완료" : "진행 중"}
        </span>
        <span className="progress-text">진행률: {section.progress}%</span>
      </div>
    </div>
  )
}

export default SectionTimerManager
