import type {
  GoalSectionConfig,
  AutoGeneratedSection,
  SectionGenerationParams,
  GoalType,
} from "../types"

// 로깅 유틸리티
const logger = {
  info: (message: string, data?: any) => {
    console.log(`[SectionGenerationService] ${message}`, data || "")
  },
  debug: (message: string, data?: any) => {
    console.debug(`[SectionGenerationService] ${message}`, data || "")
  },
  warn: (message: string, data?: any) => {
    console.warn(`[SectionGenerationService] ${message}`, data || "")
  },
  error: (message: string, error?: any) => {
    console.error(`[SectionGenerationService] ${message}`, error || "")
  },
}

// 목표 타입별 운동 매핑
const GOAL_TYPE_EXERCISES = {
  weight: {
    chest: ["벤치프레스", "덤벨 프레스", "인클라인 프레스"],
    back: ["데드리프트", "바벨로우", "풀업"],
    shoulders: ["밀리터리 프레스", "사이드 레터럴 레이즈", "프론트 레이즈"],
    arms: ["바벨 컬", "트라이셉스 딥", "해머 컬"],
    abs: ["크런치", "플랭크", "레그 레이즈"],
    legs: ["스쿼트", "레그 프레스", "런지"],
    full_body: ["버피", "마운틴 클라이머", "점프 스쿼트"],
  },
  reps: {
    chest: ["푸시업", "덤벨 플라이", "케이블 크로스오버"],
    back: ["로우 머신", "시티드 로우", "페이스 풀"],
    shoulders: ["덤벨 프레스", "리버스 플라이", "업라이트 로우"],
    arms: ["덤벨 컬", "오버헤드 익스텐션", "프리처 컬"],
    abs: ["시트업", "바이시클 크런치", "러시안 트위스트"],
    legs: ["월 스쿼트", "스텝업", "글루트 브릿지"],
    full_body: ["버피", "마운틴 클라이머", "점프 스쿼트"],
  },
  duration: {
    chest: ["푸시업", "덤벨 프레스", "인클라인 프레스"],
    back: ["로우 머신", "시티드 로우", "페이스 풀"],
    shoulders: ["덤벨 프레스", "사이드 레터럴 레이즈", "프론트 레이즈"],
    arms: ["덤벨 컬", "트라이셉스 딥", "해머 컬"],
    abs: ["크런치", "플랭크", "레그 레이즈"],
    legs: ["스쿼트", "레그 프레스", "런지"],
    full_body: ["버피", "마운틴 클라이머", "점프 스쿼트"],
  },
  frequency: {
    chest: ["벤치프레스", "푸시업", "덤벨 프레스"],
    back: ["데드리프트", "로우 머신", "풀업"],
    shoulders: ["밀리터리 프레스", "덤벨 프레스", "사이드 레터럴 레이즈"],
    arms: ["바벨 컬", "트라이셉스 딥", "해머 컬"],
    abs: ["크런치", "플랭크", "레그 레이즈"],
    legs: ["스쿼트", "레그 프레스", "런지"],
    full_body: ["버피", "마운틴 클라이머", "점프 스쿼트"],
  },
}

// 난이도별 설정
const DIFFICULTY_CONFIG = {
  beginner: {
    sets: 2,
    reps: 8,
    restTime: 90,
    weightIncrement: 2.5,
  },
  intermediate: {
    sets: 3,
    reps: 10,
    restTime: 60,
    weightIncrement: 5,
  },
  advanced: {
    sets: 4,
    reps: 12,
    restTime: 45,
    weightIncrement: 7.5,
  },
  expert: {
    sets: 5,
    reps: 15,
    restTime: 30,
    weightIncrement: 10,
  },
}

export class SectionGenerationService {
  private static instance: SectionGenerationService

  private constructor() {}

  static getInstance(): SectionGenerationService {
    if (!SectionGenerationService.instance) {
      SectionGenerationService.instance = new SectionGenerationService()
    }
    return SectionGenerationService.instance
  }

  /**
   * 목표 설정을 기반으로 운동 섹션을 자동 생성
   */
  generateSectionsFromGoal(
    goalConfig: GoalSectionConfig,
    availableMachines: any[] = []
  ): AutoGeneratedSection[] {
    const startTime = performance.now()
    logger.info("섹션 생성 시작", {
      goalType: goalConfig.goalType,
      muscleGroup: goalConfig.muscleGroup,
      targetValue: goalConfig.targetValue,
      intensity: goalConfig.intensity,
    })

    try {
      const sections: AutoGeneratedSection[] = []
      const exercises = this.getExercisesForGoal(goalConfig)
      const config = DIFFICULTY_CONFIG[goalConfig.intensity]

      exercises.forEach((exerciseName, index) => {
        const machine = this.findMatchingMachine(
          exerciseName,
          availableMachines
        )

        const section: AutoGeneratedSection = {
          id: Date.now() + index, // 임시 ID 생성
          goalId:
            goalConfig.goalType === "frequency" ? 0 : goalConfig.targetValue, // 목표 ID 또는 임시값
          exerciseName,
          machineId: machine?.id || 0,
          sets: config.sets,
          reps: config.reps,
          weight: this.calculateInitialWeight(goalConfig, config),
          restTime: config.restTime,
          order: index + 1,
          isCompleted: false,
          progress: 0,
        }

        sections.push(section)
        logger.debug("섹션 생성됨", {
          exerciseName: section.exerciseName,
          sets: section.sets,
          reps: section.reps,
          weight: section.weight,
        })
      })

      const duration = performance.now() - startTime
      logger.info("섹션 생성 완료", {
        totalSections: sections.length,
        duration: `${duration.toFixed(2)}ms`,
      })

      return sections
    } catch (error) {
      logger.error("섹션 생성 실패", error)
      throw new Error("운동 섹션 생성 중 오류가 발생했습니다.")
    }
  }

  /**
   * 목표 타입과 근육 그룹에 따른 운동 목록 반환
   */
  private getExercisesForGoal(goalConfig: GoalSectionConfig): string[] {
    const { goalType, muscleGroup } = goalConfig
    const exercises =
      GOAL_TYPE_EXERCISES[goalType as keyof typeof GOAL_TYPE_EXERCISES]?.[
        muscleGroup as keyof (typeof GOAL_TYPE_EXERCISES)[typeof goalType]
      ]

    if (!exercises) {
      logger.warn("해당 목표 타입과 근육 그룹에 대한 운동이 없습니다", {
        goalType,
        muscleGroup,
      })
      return ["기본 운동"] // 기본값
    }

    // 목표 값에 따라 운동 개수 조정
    const targetValue = goalConfig.targetValue
    let exerciseCount = 3 // 기본값

    if (goalType === "weight" || goalType === "reps") {
      exerciseCount = Math.min(Math.max(Math.floor(targetValue / 10), 2), 5)
    } else if (goalType === "duration") {
      exerciseCount = Math.min(Math.max(Math.floor(targetValue / 20), 2), 4)
    } else if (goalType === "frequency") {
      exerciseCount = Math.min(Math.max(targetValue, 2), 6)
    }

    return exercises.slice(0, exerciseCount)
  }

  /**
   * 운동 이름에 맞는 기구 찾기
   */
  private findMatchingMachine(
    exerciseName: string,
    availableMachines: any[]
  ): any | null {
    if (!availableMachines.length) return null

    // 간단한 매칭 로직 (실제로는 더 정교한 매칭이 필요)
    const machine = availableMachines.find(
      machine =>
        machine.name.toLowerCase().includes(exerciseName.toLowerCase()) ||
        exerciseName.toLowerCase().includes(machine.name.toLowerCase())
    )

    return machine || availableMachines[0] // 매칭되지 않으면 첫 번째 기구 사용
  }

  /**
   * 초기 무게 계산
   */
  private calculateInitialWeight(
    goalConfig: GoalSectionConfig,
    config: any
  ): number {
    const { goalType, targetValue, currentValue } = goalConfig

    if (goalType === "weight") {
      // 무게 목표인 경우 현재 무게에서 시작
      return Math.max(currentValue - config.weightIncrement, 0)
    } else if (goalType === "reps") {
      // 반복 횟수 목표인 경우 적당한 무게로 시작
      return Math.max(targetValue * 0.6, 10)
    } else {
      // 기타 목표는 기본 무게
      return 0
    }
  }

  /**
   * 섹션 완료 시 목표 진행률 업데이트
   */
  updateGoalProgress(
    goalConfig: GoalSectionConfig,
    completedSections: AutoGeneratedSection[]
  ): number {
    const totalSections = completedSections.length
    const completedCount = completedSections.filter(s => s.isCompleted).length

    if (totalSections === 0) return 0

    const progress = (completedCount / totalSections) * 100
    logger.info("목표 진행률 업데이트", {
      completedCount,
      totalSections,
      progress: `${progress.toFixed(1)}%`,
    })

    return Math.round(progress)
  }

  /**
   * 섹션 완료 시 다음 섹션의 무게 증가
   */
  calculateNextWeight(
    currentWeight: number,
    goalType: GoalType,
    intensity: string
  ): number {
    const config =
      DIFFICULTY_CONFIG[intensity as keyof typeof DIFFICULTY_CONFIG]

    if (goalType === "weight") {
      return currentWeight + config.weightIncrement
    }

    return currentWeight
  }

  /**
   * 목표 달성 여부 확인
   */
  checkGoalAchievement(
    goalConfig: GoalSectionConfig,
    completedSections: AutoGeneratedSection[]
  ): boolean {
    const { goalType, targetValue, currentValue } = goalConfig
    const progress = this.updateGoalProgress(goalConfig, completedSections)

    switch (goalType) {
      case "weight":
        return currentValue >= targetValue
      case "reps":
        return currentValue >= targetValue
      case "duration":
        return currentValue >= targetValue
      case "frequency":
        return completedSections.length >= targetValue
      default:
        return progress >= 100
    }
  }
}

export default SectionGenerationService
