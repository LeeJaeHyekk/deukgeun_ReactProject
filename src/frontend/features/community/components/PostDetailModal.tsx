import { useState, useEffect } from "react"
import { commentsApi } from "../../../shared/api/communityApi"
import { showToast } from "../../../shared/lib/toast"
import { useAuthContext } from "../../../shared/contexts/AuthContext"
import type {
  Post,
  Comment,
} from "../../../types/community"
import styles from "./PostDetailModal.module.css"

interface PostDetailModalProps {
  post: Post
  onClose: () => void
  onUpdate?: (
    postId: number,
    updateData: { title: string; content: string; category: string }
  ) => Promise<void>
  onDelete?: (postId: number) => Promise<void>
}

export function PostDetailModal({
  post,
  onClose,
  onUpdate,
  onDelete,
}: PostDetailModalProps) {
  const { user } = useAuthContext()
  const [comments, setComments] = useState<Comment[]>([])
  const [newComment, setNewComment] = useState("")
  const [isEditing, setIsEditing] = useState(false)
  const [editData, setEditData] = useState({
    title: post.title,
    content: post.content,
    category: typeof post.category === 'string' ? post.category : post.category.name || 'tips',
  })
  const [loading, setLoading] = useState(false)
  const [commentsLoading, setCommentsLoading] = useState(false)

  // ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÍ∞Ä Í≤åÏãúÍ∏Ä ÏûëÏÑ±ÏûêÏù∏ÏßÄ ÌôïÏù∏
  const isAuthor = user?.id === post.author?.id?.toString()

  // ÎåìÍ∏Ä Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
  useEffect(() => {
    const fetchComments = async () => {
      setCommentsLoading(true)
      try {
        console.log("ÎåìÍ∏Ä ÏöîÏ≤≠ post.id:", post.id) // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏
        const response = await commentsApi.getComments(post.id.toString())
        console.log("ÎåìÍ∏Ä API ÏùëÎãµ:", response) // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏

        // API ÏùëÎãµ Íµ¨Ï°∞ ÌôïÏù∏ Î∞è ÏïàÏ†ÑÌïú Îß§Ìïë
        let commentData: Comment[] = []

        if (Array.isArray(response)) {
          commentData = response.map((comment: any) => ({
            id: comment.id || 0,
            postId: comment.postId || post.id,
            userId: comment.userId || comment.author_id || 0,
            content: comment.content || "",
            isAnonymous: comment.isAnonymous || false,
            createdAt: new Date(comment.createdAt || comment.created_at || Date.now()),
            updatedAt: new Date(comment.updatedAt || comment.updated_at || Date.now()),
          }))
        }

        console.log("Îß§ÌïëÎêú ÎåìÍ∏Ä Îç∞Ïù¥ÌÑ∞:", commentData) // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏
        setComments(commentData)
      } catch (error: unknown) {
        console.error("ÎåìÍ∏Ä Î°úÎìú Ïã§Ìå®:", error)
        // ÎåìÍ∏Ä API ÏóêÎü¨ Ïãú ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö© (ÌÖåÏä§Ìä∏Ïö©)
        const dummyComments: Comment[] = [
          {
            id: 1,
            postId: post.id,
            userId: 1,
            content: "Ïù¥ Í≤åÏãúÍ∏Ä Ï†ïÎßê Ï¢ãÎÑ§Ïöî! üëç",
            isAnonymous: false,
            createdAt: new Date(),
            updatedAt: new Date(),
          },
          {
            id: 2,
            postId: post.id,
            userId: 2,
            content: "Ï†ÄÎèÑ ÎπÑÏä∑Ìïú Í≤ΩÌóòÏù¥ ÏûàÏñ¥Ïöî. Í≥µÍ∞êÌï©ÎãàÎã§!",
            isAnonymous: false,
            createdAt: new Date(Date.now() - 3600000),
            updatedAt: new Date(Date.now() - 3600000),
          },
        ]
        setComments(dummyComments)
        console.log("ÎçîÎØ∏ ÎåìÍ∏Ä Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©:", dummyComments) // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏
      } finally {
        setCommentsLoading(false)
      }
    }

    fetchComments()
  }, [post.id])

  // ÎåìÍ∏Ä ÏûëÏÑ±
  const handleSubmitComment = async () => {
    if (!newComment.trim()) {
      showToast("ÎåìÍ∏Ä ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", "error")
      return
    }

    console.log("ÎåìÍ∏Ä ÏûëÏÑ± ÏãúÏûë")
    console.log("Í≤åÏãúÍ∏Ä ID:", post.id)
    console.log("ÎåìÍ∏Ä ÎÇ¥Ïö©:", newComment.trim())

    try {
      console.log("ÎåìÍ∏Ä API Ìò∏Ï∂ú ÏãúÏûë")
      const createResponse = await commentsApi.createComment(post.id.toString(), newComment.trim())
      console.log("ÎåìÍ∏Ä API ÏùëÎãµ:", createResponse)
      showToast("ÎåìÍ∏ÄÏù¥ ÏûëÏÑ±ÎêòÏóàÏäµÎãàÎã§.", "success")
      setNewComment("")

      // ÎåìÍ∏Ä Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
      const listResponse = await commentsApi.getComments(post.id.toString())
      console.log("ÎåìÍ∏Ä ÏûëÏÑ± ÌõÑ ÏÉàÎ°úÍ≥†Ïπ® ÏùëÎãµ:", listResponse) // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏

      let commentData: Comment[] = []

      if (Array.isArray(listResponse)) {
        commentData = listResponse.map(comment => ({
          id: comment.id || 0,
          postId: comment.postId || post.id,
          userId: comment.userId || comment.author_id || 0,
          content: comment.content || "",
          isAnonymous: comment.isAnonymous || false,
          createdAt: new Date(comment.createdAt || comment.created_at || Date.now()),
          updatedAt: new Date(comment.updatedAt || comment.updated_at || Date.now()),
        }))
      }

      setComments(commentData)
    } catch (error: unknown) {
      console.error("ÎåìÍ∏Ä ÏûëÏÑ± Ïã§Ìå®:", error)

      // Axios ÏóêÎü¨Ïù∏ Í≤ΩÏö∞ Îçî ÏûêÏÑ∏Ìïú Ï†ïÎ≥¥ ÌëúÏãú
      if (error && typeof error === "object" && "response" in error) {
        const axiosError = error as any
        if (axiosError.response?.status === 401) {
          showToast("Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.", "error")
        } else if (axiosError.response?.status === 400) {
          showToast(
            axiosError.response?.data?.message || "ÏûòÎ™ªÎêú ÏöîÏ≤≠ÏûÖÎãàÎã§.",
            "error"
          )
        } else if (axiosError.response?.status === 500) {
          showToast(
            "ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.",
            "error"
          )
        } else {
          showToast("ÎåìÍ∏Ä ÏûëÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.", "error")
        }
      } else {
        showToast("ÎåìÍ∏Ä ÏûëÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.", "error")
      }
    }
  }

  // Í≤åÏãúÍ∏Ä ÏàòÏ†ï
  const handleUpdatePost = async () => {
    if (!onUpdate) return

    if (!editData.title.trim()) {
      showToast("Ï†úÎ™©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", "error")
      return
    }

    if (!editData.content.trim()) {
      showToast("ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", "error")
      return
    }

    setLoading(true)
    try {
      await onUpdate(post.id, editData)
      setIsEditing(false)
    } catch (error: unknown) {
      console.error("Í≤åÏãúÍ∏Ä ÏàòÏ†ï Ïã§Ìå®:", error)
      // ÏóêÎü¨ Î∞úÏÉù Ïãú ÏàòÏ†ï Î™®ÎìúÎäî Ïú†ÏßÄ
    } finally {
      setLoading(false)
    }
  }

  // Í≤åÏãúÍ∏Ä ÏÇ≠Ï†ú
  const handleDeletePost = async () => {
    if (!onDelete) return

    if (!confirm("Ï†ïÎßêÎ°ú Ïù¥ Í≤åÏãúÍ∏ÄÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
      return
    }

    setLoading(true)
    try {
      await onDelete(post.id)
      // ÏÑ±Í≥µ Ïãú Î™®Îã¨ÏùÄ Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú Îã´Ìûò
    } catch (error: unknown) {
      console.error("Í≤åÏãúÍ∏Ä ÏÇ≠Ï†ú Ïã§Ìå®:", error)
      // ÏóêÎü¨ Î∞úÏÉù Ïãú Î™®Îã¨ÏùÄ Ïó¥Î¶∞ ÏÉÅÌÉúÎ°ú Ïú†ÏßÄ
    } finally {
      setLoading(false)
    }
  }

  // Î™®Îã¨ Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Îã´Í∏∞
  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose()
    }
  }

  // ESC ÌÇ§Î°ú Î™®Îã¨ Îã´Í∏∞
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        onClose()
      }
    }

    document.addEventListener("keydown", handleEscape)
    return () => document.removeEventListener("keydown", handleEscape)
  }, [onClose])

  return (
    <div className={styles.modalOverlay} onClick={handleBackdropClick}>
      <div className={styles.modal} onClick={e => e.stopPropagation()}>
        <div className={styles.header}>
          <h2 className={styles.title}>
            {isEditing ? "Í≤åÏãúÍ∏Ä ÏàòÏ†ï" : post.title}
          </h2>
          <button className={styles.closeButton} onClick={onClose}>
            ‚úï
          </button>
        </div>

        <div className={styles.body}>
          {isEditing ? (
            <div className={styles.editForm}>
              <input
                type="text"
                value={editData.title}
                onChange={e =>
                  setEditData({ ...editData, title: e.target.value })
                }
                className={styles.titleInput}
                placeholder="Ï†úÎ™©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî"
              />
              <textarea
                value={editData.content}
                onChange={e =>
                  setEditData({ ...editData, content: e.target.value })
                }
                className={styles.contentInput}
                placeholder="ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî"
                rows={8}
              />
              <div className={styles.editActions}>
                <button
                  onClick={() => setIsEditing(false)}
                  className={styles.cancelButton}
                  disabled={loading}
                >
                  Ï∑®ÏÜå
                </button>
                <button
                  onClick={handleUpdatePost}
                  className={styles.saveButton}
                  disabled={loading}
                >
                  {loading ? "Ï†ÄÏû• Ï§ë..." : "Ï†ÄÏû•"}
                </button>
              </div>
            </div>
          ) : (
            <>
              <div className={styles.postInfo}>
                <div className={styles.authorInfo}>
                  <span className={styles.author}>{(post.author as any)?.nickname || "ÏùµÎ™Ö"}</span>
                  <span className={styles.date}>
                    {new Date(post.createdAt).toLocaleDateString()}
                  </span>
                </div>
                <div className={styles.category}>{(post.category as any)?.name || post.category}</div>
              </div>

              <div className={styles.postContent}>
                <p>{post.content}</p>
              </div>

              <div className={styles.postActions}>
                <button className={styles.likeButton}>
                  ‚ù§Ô∏è {(post as any).likeCount || 0}
                </button>
                <button className={styles.commentButton}>
                  üí¨ {(post as any).commentCount || 0}
                </button>
                {/* ÏûêÏã†Ïùò Í≤åÏãúÎ¨ºÏóêÎßå ÏàòÏ†ï/ÏÇ≠Ï†ú Î≤ÑÌäº ÌëúÏãú */}
                {isAuthor && onUpdate && (
                  <button
                    onClick={() => setIsEditing(true)}
                    className={styles.editButton}
                  >
                    ÏàòÏ†ï
                  </button>
                )}
                {isAuthor && onDelete && (
                  <button
                    onClick={handleDeletePost}
                    className={styles.deleteButton}
                    disabled={loading}
                  >
                    ÏÇ≠Ï†ú
                  </button>
                )}
              </div>
            </>
          )}

          {/* ÎåìÍ∏Ä ÏÑπÏÖò */}
          <div className={styles.commentsSection}>
            <h3>ÎåìÍ∏Ä ({comments.length})</h3>

            <div className={styles.commentForm}>
              <textarea
                value={newComment}
                onChange={e => setNewComment(e.target.value)}
                placeholder="ÎåìÍ∏ÄÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
                className={styles.commentInput}
                rows={3}
              />
              <div className={styles.commentSubmitWrapper}>
                <button
                  onClick={handleSubmitComment}
                  className={styles.commentSubmitButton}
                  disabled={!newComment.trim()}
                >
                  ÎåìÍ∏Ä ÏûëÏÑ±
                </button>
              </div>
            </div>

            <div className={styles.commentsList}>
              {commentsLoading ? (
                <div className={styles.commentsLoading}>
                  <div className={styles.commentsSpinner}></div>
                  <p>ÎåìÍ∏ÄÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</p>
                </div>
              ) : comments.length === 0 ? (
                <div className={styles.emptyComments}>
                  <p>ÏïÑÏßÅ ÎåìÍ∏ÄÏù¥ ÏóÜÏäµÎãàÎã§. Ï≤´ Î≤àÏß∏ ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±Ìï¥Î≥¥ÏÑ∏Ïöî!</p>
                </div>
              ) : (
                comments.map(comment => (
                  <div key={comment.id} className={styles.comment}>
                    <div className={styles.commentHeader}>
                      <span className={styles.commentAuthor}>
                        {comment.user?.nickname || "ÏùµÎ™Ö"}
                      </span>
                      <span className={styles.commentDate}>
                        {new Date(comment.createdAt).toLocaleDateString()}
                      </span>
                    </div>
                    <p className={styles.commentContent}>{comment.content}</p>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
